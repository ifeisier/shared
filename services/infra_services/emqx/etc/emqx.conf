## 只能发送 QOS 0 消息, 所以去掉了一些有关 QOS 1 和 QOS 2 的配置.
## 只使用 QOS 0 的原因:
##    QOS 1 和 QOS 2 有可能降低服务器的并发.
##    客户端本来就要避免幂等性.
##    将协议做成请求和响应的有利于排查错误.


node {
  name = "emqx@127.0.0.1"
  cookie = "emqxsecretcookie"
  data_dir = "data"
}

cluster {
  name = emqxcl
  discovery_strategy = manual
}

dashboard {
  listeners {
    http {
      bind = 18083
    }
  }
}

listeners {
  ssl { default { enable = false } }
  wss { default { enable = false } }
  tcp {
    default {
      enable = true
      bind = "0.0.0.0:1883"
      max_connections = 1000
    }
  }
  ws {
    default {
      enable = true
      bind = "0.0.0.0:8083"
      max_connections = 1000
    }
  }
}


authentication = [
  {
    enable = true
    mechanism = password_based
    backend = http
    method = post
    url = "http://mqtt-service.debugtest.cn/mqtt/authn-and-authz/authn/${clientid}"
    enable_pipelining = 1
    pool_size = 8
    headers {
      content-type = "application/json"
      X-Request-Source = "EMQX"
    }
    body {
      "pass_word": "${password}"
      "peer_host": "${peerhost}"
      "user_name": "${username}"
    }
  }
]


authorization {
  no_match = deny
  deny_action = disconnect
  cache {
    max_size = 1000
    ttl = 30m
  }
  sources = [
    {enable = true, path = "${EMQX_ETC_DIR}/acl.conf", type = file},
    {
      enable = true
      type = http
      method = post
      enable_pipelining = 1
      pool_size = 8
      url = "http://mqtt-service.debugtest.cn/mqtt/authn-and-authz/authz/${clientid}"
      body {
        "action": "${action}",
        "proto_name": "${proto_name}",
        "topic": "${topic}",
        "user_name": "${username}"
      }
      headers {
        content-type = "application/json"
        X-Request-Source = "EMQX"
      }
    }
  ]
}


actions {
  http {
    push {
      connector = internal
      description = "推送"
      enable = true
      parameters {
        headers {content-type = "application/json"}
        max_retries = 2
        method = post
        path = "/webhook/${clientid}"
      }
    }
  }
}
connectors {
  http {
    internal {
      enable = true
      enable_pipelining = 1
      description = "内部平台使用"
      headers {X-Request-Source = EMQX, content-type = "application/json"}
      pool_size = 8
      url = "http://mqtt-service.debugtest.cn/mqtt/authn-and-authz"
    }
  }
}
rule_engine {
  ignore_sys_message = true
  rules {
    client_connection_and_disconnection_push {
      actions = [
        "http:push"
      ]
      description = "推送客户端上线和下线"
      enable = true
      sql = """~
        SELECT
          clientid,
          event,
          timestamp,
          peername as peer_name,
          username as user_name
        FROM
          "$events/session_subscribed",
          "$events/client_connected",
          "$events/client_disconnected"~"""
    }
  }
}


mqtt {
  max_topic_alias = 0
  retain_available = false
  shared_subscription_strategy = round_robin_per_group
  exclusive_subscription = true
  strict_mode = true
  max_awaiting_rel = infinity
  max_mqueue_len = infinity
  session_expiry_interval = 0
  max_qos_allowed = 0
  mqueue_store_qos0 = false

  ## 这是客户端与服务器之间约定的心跳间隔时间, 单位通常是秒.
  ## 客户端需要在这个间隔时间内发送一个 PINGREQ 消息, 以维持连接的活跃状态.
  server_keepalive = 15
  ## 假设:
  ##    Keep Alive 间隔设置为 10 秒.
  ##    使用默认的 1.5 倍.
  ##
  ## 计算过程:
  ##    Keep Alive 超时 = 10 * 1.5 = 15 秒.
  ##
  ## 也就是说, 如果服务器在 15 秒内没有收到客户端的 PINGREQ 消息, 就会认为客户端已经断开连接.
  ## 可以根据实际需求调整 Keep Alive 倍数, 以适应不同的网络环境或客户端行为.
  keepalive_multiplier = 1.5

  ## 多长时间检测一次客户端有没有出现 Keep Alive 超时, 超时就会断开链接.
  ##
  ## server_keepalive 和 keepalive_multiplier 用来设置客户端的超时时间,
  ## keepalive_check_interval 是用来检查有没有
  keepalive_check_interval = 30s
}

flapping_detect {
  enable = false
}

log {
  console {
    enable = false
  }
  file {
    enable = true
    path = "${EMQX_LOG_DIR}/emqx.log"
    rotation_count = 128
    rotation_size = 500MB
    level = info
    formatter = json
    payload_encode = hex
  }
  throttling {
    time_window = "30s"
  }
}


sys_topics {
  sys_event_messages {
    client_connected = true
    client_disconnected = true
  }
}

retainer {
  backend {
    enable = true
    index_specs = [[1, 2, 3], [1, 3], [2, 3], [3]]
    max_retained_messages = 0
    storage_type = ram
    type = built_in_database
  }
  delivery_rate = "1000/s"
  enable = true
  max_payload_size = "1MB"
  msg_clear_interval = "0s"
  msg_expiry_interval = "0s"
  stop_publish_clear_msg = false
}
